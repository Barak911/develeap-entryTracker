on:
  push:
    branches: [ "main" ]

env:
  REGION: "ap-south-1"


jobs:
  Build-and-Test:
    runs-on: ubuntu-latest

    steps:
      # Part 1: Pull the application source code
      - name: Checkout code
        uses: actions/checkout@v3

      # Part 2: Build the application: Set up Python environment
      - name: Set up Python 3.10
        uses: actions/setup-python@v3
        with:
          python-version: "3.10"

      # Install dependencies
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # Run the application in the background
      - name: Start app.py
        run: |
          nohup python app.py &
          sleep 2
          if ! pgrep -f "python app.py"; then
            echo "Error: Application failed to start."
            exit 1
          fi

      # Part 3: Run unit tests
      - name: Test the application with curl
        run: |
          echo "Testing the application..."
          RESPONSE=$(curl -s -o response.txt -w "%{http_code}" http://localhost:5000)
          if [ "$RESPONSE" -ne 200 ]; then
            echo "Error: Expected HTTP 200 but got $RESPONSE"
            cat response.txt
            exit 1
          fi
          echo "Test successful! Application returned HTTP 200."
          echo "Response from the application:"
          cat response.txt
          exit 0

      # Stop the app
      - name: Cleanup
        run: |
          pkill -f app.py || true

  E2E-Test-and-Deploy:
    needs: Build-and-Test
    runs-on: ubuntu-latest

    steps: 
      - name: Checkout App
        uses: actions/checkout@v3

      # Configure AWS Credentials
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.REGION }}

      # Download .env from S3
      - name: Download .env file from S3
        run: |
          aws s3 cp s3://entytracker-cicd/.env .

      # Load environment variables
      - name: Load .env file
        uses: aarcangeli/load-dotenv@v1
        with:
          path: '.'
          filenames: '.env'
          expand: true  

      # Deploy to Staging: Deploy Instance
      - name: Make scripts executable
        run: |
          sed -i 's/\r$//' scripts/run-instances.sh
          sed -i 's/\r$//' scripts/userdata.sh
          chmod +x scripts/run-instances.sh
      
      # Run run-instance.sh and user-da
      - name: Launch EC2 and wait
        run: bash scripts/run-instances.sh -u scripts/userdata.sh

      # Step 1: SSM Commands - Health Checks
      - name: SSM Commands - Initiate Health Checks
        run: |
          echo "Initiating health checks via SSM..."
      
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters '{"commands": [
              "echo Starting health checks...",
              "MAX_RETRIES=30",
              "RETRY_INTERVAL=10",
              "for i in $(seq 1 $MAX_RETRIES); do",
              "  echo Checking HTTP response on port 5000...",
              "  RESPONSE=$(curl -s -o /dev/null -w \\\"%{http_code}\\\" http://localhost:5000) || RESPONSE=000",
              "  if [ \\\"$RESPONSE\\\" -eq 200 ]; then",
              "    echo HTTP check passed with response code $RESPONSE",
              "    echo Checking MySQL connectivity...",
              "    docker exec mysql-db mysql -u \\\"${DB_USER}\\\" -p\\\"${DB_PASSWORD}\\\" -e \\\"SELECT 1;\\\" && echo All checks passed! && exit 0",
              "  fi",
              "  echo Retry $i/$MAX_RETRIES: HTTP response $RESPONSE or MySQL connectivity failed. Retrying in $RETRY_INTERVAL seconds...",
              "  sleep $RETRY_INTERVAL",
              "done",
              "echo Timeout reached: Health checks failed after $((MAX_RETRIES * RETRY_INTERVAL / 60)) minutes.",
              "exit 1"
            ]}' \
            --region "$REGION" \
            --query "Command.CommandId" \
            --output text) || { echo "Error: Failed to send SSM command"; exit 1; }
      
          echo "SSM Command ID: $COMMAND_ID"
          echo "COMMAND_ID=$COMMAND_ID" >> $GITHUB_ENV
      
      # Step 2: Monitor SSM Command
      - name: SSM Commands - Monitor Health Checks
        run: |
          echo "Monitoring health check SSM command status..."
      
          for attempt in {1..30}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --region "$REGION" \
              --query "Status" \
              --output text)
      
            echo "Command status: $STATUS"
      
            if [ "$STATUS" == "Success" ]; then
              echo "Health checks passed!"
              break
            elif [ "$STATUS" == "Failed" ] || [ "$STATUS" == "Cancelled" ]; then
              echo "SSM Command failed with status: $STATUS"
              exit 1
            fi
      
            if [ $attempt -eq 30 ]; then
              echo "Timeout reached: SSM Command did not succeed within 5 minutes."
              exit 1
            fi
      
            echo "Waiting for next check... (${attempt}/30)"
            sleep 10
          done


